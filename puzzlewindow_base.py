#!/usr/bin/env python3
#FIXME:
# This is an example class generated using a bare glade file.
#
#FIXME:
"""
    Copyright (C) ilias iliadis, 2019-01-16; ilias iliadis <iliadis@kekbay.gr>

    This file is part of Sudoku Puzzle.

    Sudoku Puzzle is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Sudoku Puzzle is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Sudoku Puzzle.  If not, see <http://www.gnu.org/licenses/>.
"""

"""
        WARNING !!!

Since we are in python, any subclass of this class
will take over any method with the same name.
So do not declare here methods that exist also in the subclass.
(subclass is the class that uses the class here as Base.
Imagine the subclass as a super-duper class,
although in computing superclass is the base class)
"""
#FIXME: correct the version
__version__ = '0.0.30'
VERSIONSTR = 'v. {}'.format(__version__)

try:
    import os
    import sys

    # Gtk and related
    from gi import require_version as gi_require_version
    gi_require_version('Gtk', '3.0')
    from gi.repository import Gtk
    from gi.repository import Gdk
    from gi.repository import GObject

    # Configuration and message boxes
    from auxiliary import SectionConfig, OptionConfig
    from auxiliary import MessageBox

    # Load base window class and static methods
    from puzzlewindow_statics import *

except ImportError as eximp:
    print(eximp)
    sys.exit(-1)

class PuzzleWindowBase(object):
    #FIXME: fix the docstring.
    """ Main window with all components. """

    #def __init__(self, application, *args, **kwargs):
    def __init__(self, *args, **kwargs):
        # Set the app
        self.myparent = None
        self.passed_args = kwargs['args_to_pass']
        self.AppArgs = self.Application.MyArgs
        self.puzzle = None
        self.old_allocation = Gdk.Rectangle()
        self.old_allocation.width=0
        self.old_allocation.height=0

        # bind settings,options to a class variable
        global settings
        settings = self.settings
        global options
        options = self.options

        # Before builder.
        self._run_before_builder()

        # Read GUI from file and retrieve objects from Gtk.Builder
        thebuilder = Gtk.Builder()
        thebuilder.set_translation_domain(self.Application.id)
        try:
            thebuilder.add_from_file(os.path.join(self.AppArgs.APP_DIR,
                'ui',
                'puzzlewindow.glade')
                )
            thebuilder.connect_signals(self)
        except GObject.GError:
            print("Error reading GUI file")
            raise

        # Fire up the main window
        self.PuzzleWindow = thebuilder.get_object("PuzzleWindow")
        self.PuzzleWindow.set_application(self.Application)
        self._get_from_builder(thebuilder)
        self._post_initialisations()

        self.PuzzleWindow.show()

#********* Auto created "class defs" START ************************************************************
    def _run_before_builder(self):
        self.is_picker_visible = False
        self.working_restangle = Gdk.Rectangle()

    def _get_from_builder(self, builder):
        """ Create self names for easy access. """
        self.MainBox = builder.get_object('MainBox')
        self.boxDown = builder.get_object('boxDown')
        self.boxMenu = builder.get_object('boxMenu')
        self.boxTimer = builder.get_object('boxTimer')
        self.boxUndoRedo = builder.get_object('boxUndoRedo')
        self.boxUp = builder.get_object('boxUp')
        self.buttonHome = builder.get_object('buttonHome')
        self.buttonRedo = builder.get_object('buttonRedo')
        self.buttonUndo = builder.get_object('buttonUndo')
        self.drawingareaPuzzle = builder.get_object('drawingareaPuzzle')
        self.eventboxPuzzle = builder.get_object('eventboxPuzzle')
        self.imageClock = builder.get_object('imageClock')
        self.imageRedo = builder.get_object('imageRedo')
        self.imageUndo = builder.get_object('imageUndo')
        self.labelClock = builder.get_object('labelClock')
        self.labelVersion = builder.get_object('labelVersion')
        self.listboxPieces = builder.get_object('listboxPieces')

        # Connect signals existing in the Glade file.
        builder.connect_signals(self)

        # Connect generated by OCPgenerator signals:
        # to builder's main window
        self.PuzzleWindow.connect('delete-event', self.on_PuzzleWindow_delete_event)
        self.PuzzleWindow.connect('destroy', self.on_PuzzleWindow_destroy)
        self.PuzzleWindow.connect('size-allocate', self.on_PuzzleWindow_size_allocate)
        self.PuzzleWindow.connect('window-state-event', self.on_PuzzleWindow_window_state_event)
        self.PuzzleWindow.connect('window-state-event', self.on_PuzzleWindow_window_state_event)
        self.buttonHome.connect('clicked', self.on_buttonHome_clicked)

    def _post_initialisations(self):
        """ Do some extra initializations.

        Display the version if a labelVersion is found.
        Set defaults (try to load them from a configuration file):
            - Window size and state (width, height and if maximized)
        Load any custom settings from a configuration file.
        """
        if 'trigger_before_exit' in self.passed_args:
            # must be a function on calling class
            self.trigger_before_exit = self.passed_args['trigger_before_exit']
            self.return_parameters = None

        # Bind message boxes.
        self.MessageBox = MessageBox(self.PuzzleWindow, self.Application)
        self.msg = self.MessageBox.Message
        self.are_you_sure = self.MessageBox.are_you_sure

        # Reset MainWindow to a default or previous size and state.
        width = settings.get('width', 350)
        height = settings.get('height', 350)
        self.PuzzleWindow.set_title(self.AppArgs.localizedname)
        self.PuzzleWindow.resize(width, height)
        self.PuzzleWindow.set_icon(self.Application.icon)
        if settings.get_bool('maximized', False):
            self.PuzzleWindow.maximize()

        # Set the label for labelVersion
        self.labelVersion.set_label(self.AppArgs.version)
        self.labelVersion.set_tooltip_text(_("Version of this window:") + "\n" + VERSIONSTR)

        # Load any other settings here.
        self.exiting = False
        self.playing_history = False
        self.previous_sel = None

        self.AppArgs.picker.PickerWindow.set_transient_for(self.PuzzleWindow)
        self.AppArgs.picker.response_from_picker = self.response_from_picker
        self.listboxPieces.set_visible(self.AppArgs.show_pieces)
        self.boxTimer.set_visible(self.AppArgs.show_timer)

        self.eventboxPuzzle.drag_dest_set(0, [],0)

#********* Auto created handlers START *********************************
    def on_buttonHome_clicked(self, widget, *args):
        """ Handler for buttonHome.clicked. """
        self.picker_resize()
        self.exit_requested()

    def on_buttonRedo_clicked(self, widget, *args):
        """ Handler for buttonRedo.clicked. """
        self.puzzle_set_number(self, undoredo = MOVE_REDO)

    def on_buttonUndo_clicked(self, widget, *args):
        """ Handler for buttonUndo.clicked. """
        self.puzzle_set_number(self, undoredo = MOVE_UNDO)

    def on_drawingareaPuzzle_draw(self, widget, cr, *args):
        """ Handler for drawingareaPuzzle.draw. """
        if self.puzzle:
            an_9 = self.puzzle.draw(cr,
                widget.get_allocated_width(),
                widget.get_allocated_height())
            if not self.init_picker_done:
                self.init_picker_done = True
                self.picker_resize(an_9)


    def on_eventboxPuzzle_button_release_event(self, widget, event, *args):
        """ Handler for eventboxPuzzle.button-release-event. """
        col, row = col_row_of_x_y_in_restangle(event.x, event.y,
            self.working_restangle)
        #print(col, row , 'col, row ')
        if col >= 0 and row >=0 and col < 9 and row < 9:
            selected = int(col) * 9 + int(row)
            self.puzzle_move_cursor(selected)
            if self.is_picker_visible:
                self.picker_hide()
            else:
                if not self.puzzle.puzzlenums[selected]['const']:
                    if event.button == 1:
                        self.picker_show(event, col, row)
                        #full_size = self.eventboxPuzzle.get_allocation()
                        self.AppArgs.picker.PickerWindow.show_all()
                        self.AppArgs.picker.PickerWindow.grab_focus()
                        #return True

    def on_eventboxPuzzle_drag_data_received(self, widget, context, x, y, selection_data, info, time_, *args):
        """ Handler for eventboxPuzzle.drag-data-received. """
        if self.number_picked:
            thenum = int(self.number_picked)
            self.number_picked  = None
            col, row = col_row_of_x_y_in_restangle(x, y, self.working_restangle)
            if col >= 0 and row >=0 and col < 9 and row < 9:
                cell_selected = int(col) * 9 + int(row)
                self.puzzle_move_cursor(cell_selected)
                if not self.puzzle.puzzlenums[self.puzzle.current_cell]['const']:
                    self.puzzle_set_number(thenum)
        #context.drag_finish(True, False, time_)

    def on_eventboxPuzzle_drag_drop(self, widget, context, x, y, time_, *args):
        """ Handler for eventboxPuzzle.drag-drop. """
        widget.drag_get_data(context, context.list_targets()[-1], time_)

    def on_eventboxPuzzle_drag_motion(self, widget, context, x, y, time_, *args):
        """ Handler for eventboxPuzzle.drag-motion. """
        #TODO: check if in a valid square?
        Gdk.drag_status(context, Gdk.DragAction.COPY, time_)
        return True

    def on_eventboxPuzzle_size_allocate(self, widget, allocation, *args):
        """ Handler for eventboxPuzzle.size-allocate. """
        if (self.old_allocation.width != allocation.width) or (self.old_allocation.height != allocation.height):
            #print('on_PuzzleWindow_size_allocate 1', self.old_allocation.width, allocation.width,
                        #self.old_allocation.height, allocation.height)
            self.old_allocation = allocation
            sizes = self.eventboxPuzzle.get_allocation()
            min_size = min(sizes.width, sizes.height)
            self.working_restangle.x = int((sizes.width - min_size) / 2)
            self.working_restangle.y = int((sizes.height - min_size) / 2)
            self.working_restangle.width = int(min_size)
            self.working_restangle.height = int(min_size)
            self.picker_resize()
            #print('on_PuzzleWindow_size_allocate 2', self.working_restangle.x, "#", sizes.width, "#", sizes.height , min_size)

#********* Auto created handlers END ***********************************

#********* Standard handlers START *************************************
    def msg_not_yet(self):
        self.msg(_('Not yet implemented'))

    def on_buttonAbout_clicked(self, widget, *args):
        """ Handler for buttonAbout.clicked. """
        #TODO: Check if used.
        self.MessageBox.AboutBox()
#"configure-event"
    def on_PuzzleWindow_configure_event(self, widget, event, *args):
        """ Handler for our main window: configure-event. """

    def on_PuzzleWindow_delete_event(self, widget, event, *args):
        """ Handler for our main window: delete-event. """
        return (self.exit_requested())

    def on_PuzzleWindow_destroy(self, widget, *args):
        """ Handler for our main window: destroy. """
        return (self.exit_requested('from_destroy'))

    def on_PuzzleWindow_size_allocate(self, widget, allocation, *args):
        """ Handler for our main window: size-allocate. """
        if not settings.get_bool('maximized', False):
            width, height = self.PuzzleWindow.get_size()
            settings.set('width', width)
            settings.set('height', height)

    def on_PuzzleWindow_window_state_event(self, widget, event, *args):
        """ Handler for our main window: window-state-event. """
        settings.set('maximized',
            ((int(event.new_window_state) & Gdk.WindowState.ICONIFIED) != Gdk.WindowState.ICONIFIED) and
            ((int(event.new_window_state) & Gdk.WindowState.MAXIMIZED) == Gdk.WindowState.MAXIMIZED)
            )

#********* Standard handlers END ***************************************
#********* Standard exit defs START *********************************************************
    def exit_requested(self, *args, **kwargs):
        """ Final work before exit. """
        self.exiting = True
        self.PuzzleWindow.set_transient_for()
        self.PuzzleWindow.set_modal(False)
        if 'from_destroy' in args:
            self.picker_hide()
            self.set_unhandled_settings()# also saves all settings
            return True
        else:
            # Check if we should provide info to caller
            if 'trigger_before_exit' in self.passed_args:
                self.trigger_before_exit(exiting = True,
                    return_parameters = self.return_parameters)
            self.PuzzleWindow.destroy()

    def present(self):
        """ Show the window. """
        if self.passed_args['continue']:
            self.puzzle_continue()
            return
        self.puzzle_start()

    def set_unhandled_settings(self):
        """ Set, before exit, any settings not applied during the session.

        Additionally, flush all settings to .conf file.
        """
        # Set any custom settings or options
        # which where not setted (ex. on some widget's state changed)
        options.set('last_solved', self.puzzle.solved)
        options.set('last_time', str(self.timepassed.days)+','+str(self.timepassed.seconds))
        options.set('last_history', ','.join(self.puzzle.history))
        options.set('last_undos', self.puzzle.undos)

        # Save all settings
        settings.save()
#********* Standard exit defs END **************************************
#********* Auto created "class defs" END **************************************************************

#********* Window class  END***************************************************************************
