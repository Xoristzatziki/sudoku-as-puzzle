#!/usr/bin/env python3
#FIXME:
# This is an example class generated using a bare glade file.
#
#FIXME:
"""
    Copyright (C) ilias iliadis, 2019-01-16; ilias iliadis <iliadis@kekbay.gr>

    This file is part of Sudoku Puzzle.

    Sudoku Puzzle is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Sudoku Puzzle is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Sudoku Puzzle.  If not, see <http://www.gnu.org/licenses/>.
"""

"""
        WARNING !!!

Since we are in python, any subclass of this class
will take over any method with the same name.
So do not declare here methods that exist also in the subclass.
(subclass is the class that uses the class here as Base.
Imagine the subclass as a super-duper class,
although in computing superclass is the base class)
"""
#FIXME: correct the version
__version__ = '0.0.30'
VERSIONSTR = 'v. {}'.format(__version__)

try:
    import os
    import sys

    # Gtk and related
    from gi import require_version as gi_require_version
    gi_require_version('Gtk', '3.0')
    from gi.repository import Gtk
    from gi.repository import Gdk
    from gi.repository import GObject

    # Configuration and message boxes
    from auxiliary import SectionConfig, OptionConfig
    from auxiliary import MessageBox

    # Load base window class and static methods
    from startwindow_statics import *

except ImportError as eximp:
    print(eximp)
    sys.exit(-1)

class StartWindowBase(object):
    #FIXME: fix the docstring.
    """ Main window with all components. """

    def __init__(self, application, *args, **kwargs):
        # Set the app
        self.myparent = None
        self.custom_args = kwargs['custom_args']


        # bind settings,options to a class variable
        global settings
        settings = self.settings
        global options
        options = self.options

        # Before builder.
        self._run_before_builder()

        # Read GUI from file and retrieve objects from Gtk.Builder
        thebuilder = Gtk.Builder()
        thebuilder.set_translation_domain(self.Application.id)
        try:
            thebuilder.add_from_file(os.path.join(self.AppArgs.APP_DIR,
                'ui',
                'startwindow.glade')
                )
            thebuilder.connect_signals(self)
        except GObject.GError:
            print("Error reading GUI file")
            raise

        # Fire up the main window
        self.StartWindow = thebuilder.get_object("StartWindow")
        self.StartWindow.set_application(self.Application)
        self._get_from_builder(thebuilder)
        self._post_initialisations()

        self.StartWindow.show()
        self.create_picker()

#********* Auto created "class defs" START ************************************************************
    def _run_before_builder(self):
        pass

    def _get_from_builder(self, builder):
        """ Create self names for easy access. """
        self.MainBox = builder.get_object('MainBox')
        self.boxForFooter = builder.get_object('boxForFooter')
        self.buttonAbout = builder.get_object('buttonAbout')
        self.buttonContinue = builder.get_object('buttonContinue')
        self.buttonExit = builder.get_object('buttonExit')
        self.buttonNewPuzzle = builder.get_object('buttonNewPuzzle')
        self.buttonOptions = builder.get_object('buttonOptions')
        self.dummylabel = builder.get_object('dummylabel')
        self.labelInfo = builder.get_object('labelInfo')
        self.labelVersion = builder.get_object('labelVersion')

        # Connect signals existing in the Glade file.
        builder.connect_signals(self)

        # Connect generated by OCPgenerator signals:
        # to builder's main window
        self.StartWindow.connect('delete-event', self.on_StartWindow_delete_event)
        self.StartWindow.connect('destroy', self.on_StartWindow_destroy)
        self.StartWindow.connect('size-allocate', self.on_StartWindow_size_allocate)
        self.StartWindow.connect('window-state-event', self.on_StartWindow_window_state_event)
        self.buttonAbout.connect('clicked', self.on_buttonAbout_clicked)
        self.buttonContinue.connect('clicked', self.on_buttonContinue_clicked)
        self.buttonExit.connect('clicked', self.on_buttonExit_clicked)
        self.buttonNewPuzzle.connect('clicked', self.on_buttonNewPuzzle_clicked)
        self.buttonOptions.connect('clicked', self.on_buttonOptions_clicked)

    def _post_initialisations(self):
        """ Do some extra initializations.

        Display the version if a labelVersion is found.
        Set defaults (try to load them from a configuration file):
            - Window size and state (width, height and if maximized)
        Load any custom settings from a configuration file.
        """
        if 'parent' in self.custom_args:#Is a child window, get the parent window
            self.myparent = self.custom_args['parent']

        if 'transient_for' in self.custom_args:
            self.set_transient_for(self.custom_args['transient_for'])
            # but modality can be false, and parent may not be present
            if 'is_modal' in self.custom_args:
                self.set_modal(self.custom_args['is_modal'])

        if 'trigger_before_exit' in self.custom_args:
            # must be a function on calling class
            self.trigger_before_exit = self.custom_args['trigger_before_exit']
            self.return_parameters = None

        # Bind message boxes.
        self.MessageBox = MessageBox(self.StartWindow, self.Application)
        self.msg = self.MessageBox.Message
        self.are_you_sure = self.MessageBox.are_you_sure

        # Reset MainWindow to a default or previous size and state.
        width = settings.get('width', 350)
        height = settings.get('height', 350)
        self.StartWindow.set_title(self.AppArgs.localizedname + " - " + _('Home'))
        self.StartWindow.resize(width, height)
        self.StartWindow.set_icon(self.Application.icon)
        if settings.get_bool('maximized', False):
            self.StartWindow.maximize()

        # Set the label for labelVersion
        self.labelVersion.set_label(self.AppArgs.version)
        self.labelVersion.set_tooltip_text(_("Version of this window:") + "\n" + VERSIONSTR)

        # Load any other settings here.
        self.reload_options()
        self.create_picker()

#********* Auto created handlers START *********************************
    def on_buttonContinue_clicked(self, widget, *args):
        """ Handler for buttonContinue.clicked. """
        self.open_PuzzleWindow(True)

    def on_buttonNewPuzzle_clicked(self, widget, *args):
        """ Handler for buttonNewPuzzle.clicked. """
        self.open_PuzzleWindow()

    def on_buttonOptions_clicked(self, widget, *args):
        """ Handler for buttonOptions.clicked. """
        self.open_OptionsWindow()

#********* Auto created handlers END ***********************************

#********* Standard handlers START *************************************
    def msg_not_yet(self):
        self.msg(_('Not yet implemented'))

    def on_buttonAbout_clicked(self, widget, *args):
        """ Handler for buttonAbout.clicked. """
        #TODO: Check if used.
        self.MessageBox.AboutBox()

    def on_buttonExit_clicked(self, widget, *args):
        """ Handler for buttonExit.clicked. """
        #TODO: Check if used.
        self.exit_requested()

    def on_StartWindow_delete_event(self, widget, event, *args):
        """ Handler for our main window: delete-event. """
        return (self.exit_requested())

    def on_StartWindow_destroy(self, widget, *args):
        """ Handler for our main window: destroy. """
        return (self.exit_requested('from_destroy'))

    def on_StartWindow_size_allocate(self, widget, allocation, *args):
        """ Handler for our main window: size-allocate. """
        self.save_my_size()

    def on_StartWindow_window_state_event(self, widget, event, *args):
        """ Handler for our main window: window-state-event. """
        settings.set('maximized',
            ((int(event.new_window_state) & Gdk.WindowState.ICONIFIED) != Gdk.WindowState.ICONIFIED) and
            ((int(event.new_window_state) & Gdk.WindowState.MAXIMIZED) == Gdk.WindowState.MAXIMIZED)
            )
        self.save_my_size()

#********* Standard handlers END ***************************************
#********* Standard exit defs START *********************************************************
    def exit_requested(self, *args, **kwargs):
        """ Final work before exit. """
        self.StartWindow.set_transient_for()
        self.StartWindow.set_modal(False)
        self.set_unhandled_settings()# also saves all settings
        if 'from_destroy' in args:
            return True
        else:
            # Check if we should provide info to caller
            if 'trigger_before_exit' in self.custom_args:
                self.trigger_before_exit(exiting = True,
                    return_parameters = self.return_parameters)
            self.StartWindow.destroy()

    def present(self):
        """ Show the window. """
        pass

    def save_my_size(self):
        """ Save the window size into settings, if not maximized. """
        if not settings.get_bool('maximized', False):
            width, height = self.StartWindow.get_size()
            settings.set('width', width)
            settings.set('height', height)

    def set_unhandled_settings(self):
        """ Set, before exit, any settings not applied during the session.

        Additionally, flush all settings to .conf file.
        """
        # Set any custom settings
        # which where not setted (ex. on some widget's state changed)

        # Save all settings
        settings.save()
#********* Standard exit defs END **************************************
#********* Auto created "class defs" END **************************************************************

#********* Window class  END***************************************************************************
